// wld l3bd hato flien wana mdabz m3ah offline
importScripts("https://cdn.jsdelivr.net/npm/pouchdb@7.3.0/dist/pouchdb.min.js");
importScripts("workerhandlers.js");
// importScripts("pouchdb.min.js");



// remote cache where we save the get request where the connection is live
let remoteCache = new this.PouchDB('remote-cache');

// pending cache where we store the post is there is no connection
const pendingCache = new this.PouchDB('pending-cache');

// getting info from cache
remoteCache.info().then(info => console.log(info));
pendingCache.info().then(info => console.log(info));

// when the connection is active we save the result in a cache
self.addEventListener('fetch', (event) => {

  // test if we getting responce findAll from etatEtapeCompagne
  if (event.request.method == "GET" && event.request.url.indexOf('api/admin/etatEtapeCampagne/') > -1){
    console.log('INTERCEPT GET REQUEST', event.request.url);
    event.respondWith(this.handleGetRequest(event.request));
    event.stopImmediatePropagation();
  }   // test if we sending post from etatEtapeCompagne to the same url
  else if (event.request.method == "POST" && event.request.url.indexOf('api/admin/etatEtapeCampagne/') > -1){
    console.log('INTERCEPT POST REQUEST', event.request.url);
    // send to method [ handlePostRequest(event.request) ] and the same other
    event.respondWith(this.handlePostRequest(event.request));

    // Allows to stop propagation to NGSW to avoid duplicate requests
    event.stopImmediatePropagation();
  }

});

// create a time interval to test if the connection on/off
const backgroundSyncInterval = setInterval(async () => {
  // get cache content by length
  const pendingCount = (await pendingCache.allDocs()).total_rows;
  // if cache clean
  if (pendingCount < 1)
    return console.log('LOCAL CACHE IS CLEAN');
  // if cache not clean
  console.log('LOCAL CACHE IS NOT CLEAN', pendingCount);

  // if there is no connection return a log and exit
  if (navigator.onLine === false) // Strict equal operator because it can be undefined on some browsers
    return console.log('OFFLINE: SKIPPING SYNC');

  // if there is a connection and the cache is not clean
  // get the content of the pending cache
  const allDocs = await pendingCache.allDocs({ include_docs: true });

  // parcourir allDocs(pending cache) content & save the post that they wasn't saved when the connection off
  // if(allDocs.rows.length > 0)
  allDocs.rows.forEach(row => {
      const {_id, _rev, ...doc} = row.doc;
      // try {
        fetch(`http://localhost:8036/api/admin/etatEtapeCampagne/`, {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify(doc)
        }).then(response => {
          if (response.status == 200 || response.status == 201) {
            console.log("SUCCESSFULLY SYNCED", doc);
            pendingCache.remove(row.doc._id, row.doc._rev);
          }
        });
        // for debug
        console.log('row: ', row);
        console.log('doc: ', doc);
      // } catch (error) {
      //   console.log('connection refused');
      //   throw error;
      // }
    }
  );

},1000);

// Import base service worker (NGSW) generated by Angular CLI
// ! Must be imported last as it can override our listeners
// this is all in the service-worker
importScripts('./ngsw-worker.js');


/*
// Import PouchDB
importScripts("https://cdn.jsdelivr.net/npm/pouchdb@7.3.0/dist/pouchdb.min.js");
importScripts("workerhandlers.js");

let remoteCache = new this.PouchDB('remote-cache');
const pendingCache = new this.PouchDB('pending-cache');
remoteCache.info().then(info => console.log(info));
pendingCache.info().then(info => console.log(info));

// Add our custom logic

// Listen to fetch events on the backend and store the response in the cache
self.addEventListener('fetch', (event) => {
    if (event.request.method == "GET" && event.request.url.indexOf('mockapi.io/forms') > -1) {
        console.log('INTERCEPT GET REQUEST', event.request.url);
        event.respondWith(this.handleGetRequest(event.request));

        // Allows to stop propagation to NGSW to avoid duplicate requests
        event.stopImmediatePropagation();
    } else if (event.request.method == "POST" && event.request.url.indexOf('mockapi.io/forms') > -1) {
        console.log('INTERCEPT POST REQUEST', event.request.url);
        event.respondWith(this.handlePostRequest(event.request));

        // Allows to stop propagation to NGSW to avoid duplicate requests
        event.stopImmediatePropagation();
    }
});

/!*  Best practice: use Background Sync (aka Periodic Sync) API of the service worker
    https://developer.mozilla.org/en-US/docs/Web/API/Web_Periodic_Background_Synchronization_API
    https://developer.chrome.com/blog/background-sync/
    We wonâ€™t use it here because it is not standard yet *!/


const backgroundSyncInterval = setInterval(async () => {
    const pendingCount = (await pendingCache.allDocs()).total_rows;
    if (pendingCount < 1)
        return console.log('LOCAL CACHE CLEAN');

    console.log('LOCAL CACHE NOT CLEAN', pendingCount);
    if (navigator.onLine === false) // Strict equal operator because it can be undefined on some browsers
        return console.log('OFFLINE: SKIPPING SYNC');

    const allDocs = await pendingCache.allDocs({ include_docs: true });
    allDocs.rows.forEach(row => {
        const { _id, _rev, ...doc } = row.doc;
        fetch(`https://60c785ddafc88600179f54d0.mockapi.io/forms`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(doc)
        }).then(response => {
            if (response.status == 200 || response.status == 201) {
                console.log("SUCCESSFULLY SYNCED", doc);
                pendingCache.remove(row.doc._id, row.doc._rev);
            }
        });
    });
}, 1000)

// Import base service worker (NGSW) generated by Angular CLI
// ! Must be imported last as it can override our listeners
importScripts('./ngsw-worker.js');
*/
